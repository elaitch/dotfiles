diff --git a/vanilla.dwm.c b/dwm.c
index f896170..8c4f4e3 100644
--- a/vanilla.dwm.c
+++ b/dwm.c
@@ -110,6 +110,8 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct Pertag Pertag;
+
 struct Monitor {
 	char ltsymbol[16];
 	float mfact;
@@ -129,6 +131,7 @@ struct Monitor {
 	Monitor *next;
 	Window barwin;
 	const Layout *lt[2];
+        Pertag *pertag;
 };
 
 typedef struct {
@@ -146,6 +149,7 @@ static Bool applysizehints(Client *c, int *x, int *y, int *w, int *h, Bool inter
 static void arrange(Monitor *m);
 static void arrangemon(Monitor *m);
 static void attach(Client *c);
+static void attachaside(Client *c);
 static void attachstack(Client *c);
 static void buttonpress(XEvent *e);
 static void checkotherwm(void);
@@ -163,12 +167,13 @@ static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
-static void enternotify(XEvent *e);
+/*static void enternotify(XEvent *e);*/
 static void expose(XEvent *e);
 static void focus(Client *c);
 static void focusin(XEvent *e);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
+static void gaplessgrid(Monitor *m);
 static Bool getrootptr(int *x, int *y);
 static long getstate(Window w);
 static Bool gettextprop(Window w, Atom atom, char *text, unsigned int size);
@@ -185,6 +190,7 @@ static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
 static Client *nexttiled(Client *c);
 static void pop(Client *);
+static void pop(Client *);
 static void propertynotify(XEvent *e);
 static void quit(const Arg *arg);
 static Monitor *recttomon(int x, int y, int w, int h);
@@ -205,6 +211,8 @@ static void setup(void);
 static void showhide(Client *c);
 static void sigchld(int unused);
 static void spawn(const Arg *arg);
+static void spiral(Monitor *mon);
+static void swapfocus();
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *);
@@ -226,6 +234,7 @@ static void updatewindowtype(Client *c);
 static void updatetitle(Client *c);
 static void updatewmhints(Client *c);
 static void view(const Arg *arg);
+static void view_adjacent(const Arg *arg);
 static Client *wintoclient(Window w);
 static Monitor *wintomon(Window w);
 static int xerror(Display *dpy, XErrorEvent *ee);
@@ -234,6 +243,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
 
 /* variables */
+static Client *prevclient = NULL;
+static Client *prevtiled(Client *c); 
+static void pushup(const Arg *arg);
+static void pushdown(const Arg *arg);
+static void centerwindow(const Arg *arg);
 static const char broken[] = "broken";
 static char stext[256];
 static int screen;
@@ -247,7 +261,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 	[ConfigureRequest] = configurerequest,
 	[ConfigureNotify] = configurenotify,
 	[DestroyNotify] = destroynotify,
-	[EnterNotify] = enternotify,
+/*	[EnterNotify] = enternotify, */
 	[Expose] = expose,
 	[FocusIn] = focusin,
 	[KeyPress] = keypress,
@@ -270,6 +284,16 @@ static Window root;
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
+struct Pertag {
+       unsigned int curtag, prevtag; /* current and previous tag */
+       int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+       float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+       unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+       const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+       Bool showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+};
+
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -401,6 +425,17 @@ attach(Client *c) {
 }
 
 void
+attachaside(Client *c) {
+       Client *at = nexttiled(c->mon->clients);;
+       if(c->mon->sel == NULL || c->mon->sel->isfloating || !at) {
+               attach(c);
+               return;
+       }
+       c->next = at->next;
+       at->next = c;
+}
+
+void
 attachstack(Client *c) {
 	c->snext = c->mon->stack;
 	c->mon->stack = c;
@@ -423,10 +458,17 @@ buttonpress(XEvent *e) {
 	}
 	if(ev->window == selmon->barwin) {
 		i = x = 0;
-		do
-			x += TEXTW(tags[i]);
-		while(ev->x >= x && ++i < LENGTH(tags));
-		if(i < LENGTH(tags)) {
+ unsigned int occ = 0;
+               for(c = m->clients; c; c = c->next)
+                       occ |= c->tags;
+               do {
+                       /* do not reserve space for vacant tags */
+                       if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+                               continue;
+			
+             x+=   TEXTW(tags[i]);
+                } while(ev->x >= x && ++i < LENGTH(tags));		
+                if(i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
 		}
@@ -631,7 +673,7 @@ configurerequest(XEvent *e) {
 Monitor *
 createmon(void) {
 	Monitor *m;
-
+        int i;
 	if(!(m = (Monitor *)calloc(1, sizeof(Monitor))))
 		die("fatal: could not malloc() %u bytes\n", sizeof(Monitor));
 	m->tagset[0] = m->tagset[1] = 1;
@@ -642,6 +684,25 @@ createmon(void) {
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+         if(!(m->pertag = (Pertag *)calloc(1, sizeof(Pertag))))
+               die("fatal: could not malloc() %u bytes\n", sizeof(Pertag));
+       m->pertag->curtag = m->pertag->prevtag = 1;
+       for(i=0; i <= LENGTH(tags); i++) {
+               /* init nmaster */
+               m->pertag->nmasters[i] = m->nmaster;
+
+               /* init mfacts */
+               m->pertag->mfacts[i] = m->mfact;
+
+               /* init layouts */
+               m->pertag->ltidxs[i][0] = m->lt[0];
+               m->pertag->ltidxs[i][1] = m->lt[1];
+               m->pertag->sellts[i] = m->sellt;
+
+               /* init showbar */
+               m->pertag->showbars[i] = m->showbar;
+       }
+
 	return m;
 }
 
@@ -703,12 +764,13 @@ drawbar(Monitor *m) {
 	}
 	x = 0;
 	for(i = 0; i < LENGTH(tags); i++) {
-		w = TEXTW(tags[i]);
+	 /* do not draw vacant tags */
+               if(!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+                       continue;
+         	w = TEXTW(tags[i]);
 		drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
 		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
-		drw_rect(drw, x, 0, w, bh, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-		           occ & 1 << i, urg & 1 << i);
-		x += w;
+x += w;
 	}
 	w = blw = TEXTW(m->ltsymbol);
 	drw_setscheme(drw, &scheme[SchemeNorm]);
@@ -731,7 +793,6 @@ drawbar(Monitor *m) {
 		if(m->sel) {
 			drw_setscheme(drw, m == selmon ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
 			drw_text(drw, x, 0, w, bh, m->sel->name, 0);
-			drw_rect(drw, x, 0, w, bh, m->sel->isfixed, m->sel->isfloating, 0);
 		}
 		else {
 			drw_setscheme(drw, &scheme[SchemeNorm]);
@@ -851,6 +912,44 @@ focusstack(const Arg *arg) {
 	}
 }
 
+void
+gaplessgrid(Monitor *m) {
+       unsigned int n, cols, rows, cn, rn, i, cx, cy, cw, ch;
+       Client *c;
+
+       for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) ;
+       if(n == 0)
+               return;
+
+       /* grid dimensions */
+       for(cols = 0; cols <= n/2; cols++)
+               if(cols*cols >= n)
+                       break;
+       if(n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+               cols = 2;
+       rows = n/cols;
+
+       /* window geometries */
+       cw = cols ? m->ww / cols : m->ww;
+       cn = 0; /* current column number */
+       rn = 0; /* current row number */
+       for(i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+               if(i/rows + 1 > cols - n%cols)
+                       rows = n/cols + 1;
+               ch = rows ? m->wh / rows : m->wh;
+               cx = m->wx + cn*cw;
+               cy = m->wy + rn*ch;
+               resize(c, cx, cy, cw - 2 * c->bw, ch - 2 * c->bw, False);
+               rn++;
+               if(rn >= rows) {
+                       rn = 0;
+                       cn++;
+               }
+       }
+}
+
+
+
 Atom
 getatomprop(Client *c, Atom prop) {
 	int di;
@@ -866,6 +965,14 @@ getatomprop(Client *c, Atom prop) {
 	return atom;
 }
 
+void
+swapfocus(){
+       focus(prevclient);
+}
+
+
+
+
 Bool
 getrootptr(int *x, int *y) {
 	int di;
@@ -958,7 +1065,7 @@ grabkeys(void) {
 
 void
 incnmaster(const Arg *arg) {
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);	
 	arrange(selmon);
 }
 
@@ -1051,7 +1158,7 @@ manage(Window w, XWindowAttributes *wa) {
 		c->isfloating = c->oldstate = trans != None || c->isfixed;
 	if(c->isfloating)
 		XRaiseWindow(dpy, c->win);
-	attach(c);
+	attachaside(c);
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
 	                (unsigned char *) &(c->win), 1);
@@ -1089,16 +1196,26 @@ maprequest(XEvent *e) {
 
 void
 monocle(Monitor *m) {
-	unsigned int n = 0;
+	unsigned int n = 0, r = 0;
 	Client *c;
 
 	for(c = m->clients; c; c = c->next)
 		if(ISVISIBLE(c))
 			n++;
-	if(n > 0) /* override layout symbol */
-		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
-	for(c = nexttiled(m->clients); c; c = nexttiled(c->next))
-		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, False);
+	if(n > 1) /* override layout symbol */
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "x%d", n);
+for(c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+               /* remove border when in monocle layout */
+               if(c->bw) {
+                       c->oldbw = c->bw;
+                       c->bw = 0;
+                       r = 1;
+               }
+                 resize(c, m->wx - c->bw, m->wy, m->ww, m->wh, False);
+		if(r)
+		resizeclient(c, m->wx, m->wy, m->ww - (2 * c->bw), m->wh - (2 * c->bw));
+       }
+
 }
 
 void
@@ -1471,10 +1588,14 @@ setfullscreen(Client *c, Bool fullscreen) {
 
 void
 setlayout(const Arg *arg) {
-	if(!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
+ 	if(!arg || !arg->v || arg->v != selmon->lt[selmon->sellt]) {
+               selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+               selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+       }
+	
 	if(arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+	selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+       selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
 	if(selmon->sel)
 		arrange(selmon);
@@ -1492,7 +1613,7 @@ setmfact(const Arg *arg) {
 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if(f < 0.1 || f > 0.9)
 		return;
-	selmon->mfact = f;
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
 	arrange(selmon);
 }
 
@@ -1610,7 +1731,7 @@ tagmon(const Arg *arg) {
 
 void
 tile(Monitor *m) {
-	unsigned int i, n, h, mw, my, ty;
+	unsigned int i, n, h, mw, my, ty, r;
 	Client *c;
 
 	for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
@@ -1621,22 +1742,42 @@ tile(Monitor *m) {
 		mw = m->nmaster ? m->ww * m->mfact : 0;
 	else
 		mw = m->ww;
-	for(i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		for(i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++, r = 0) {
+               if(n == 1) {
+                       if (c->bw) {
+                               /* remove border when only one window is on the current tag */
+                               c->oldbw = c->bw;
+                               c->bw = 0;
+                               r = 1;
+                       }
+               }
+               else if(!c->bw && c->oldbw) {
+                       /* restore border when more than one window is displayed */
+                       c->bw = c->oldbw;
+                       c->oldbw = 0;
+                       r = 1;
+               }
+
 		if(i < m->nmaster) {
 			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
 			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), False);
 			my += HEIGHT(c);
+
 		}
 		else {
 			h = (m->wh - ty) / (n - i);
 			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+		if(r)
+ 				resizeclient(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw));
 			ty += HEIGHT(c);
-		}
+ }
+	
+        }
 }
 
 void
 togglebar(const Arg *arg) {
-	selmon->showbar = !selmon->showbar;
+	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
 	updatebarpos(selmon);
 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
 	arrange(selmon);
@@ -1649,9 +1790,17 @@ togglefloating(const Arg *arg) {
 	if(selmon->sel->isfullscreen) /* no support for fullscreen windows */
 		return;
 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-	if(selmon->sel->isfloating)
-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+	if(selmon->sel->isfloating) {
+               /* restore border when moving window into floating mode */
+               if(!selmon->sel->bw && selmon->sel->oldbw) {
+                       selmon->sel->bw = selmon->sel->oldbw;
+                       selmon->sel->oldbw = 0;
+               }
+
+	
+	resize(selmon->sel, selmon->sel->x, selmon->sel->y,
 		       selmon->sel->w, selmon->sel->h, False);
+}
 	arrange(selmon);
 }
 
@@ -1672,9 +1821,29 @@ toggletag(const Arg *arg) {
 void
 toggleview(const Arg *arg) {
 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
-
+        int i;
 	if(newtagset) {
+	if(newtagset == ~0) {
+                       selmon->pertag->prevtag = selmon->pertag->curtag;
+                       selmon->pertag->curtag = 0;
+               }
+               /* test if the user did not select the same tag */
+               if(!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+                       selmon->pertag->prevtag = selmon->pertag->curtag;
+                       for (i=0; !(newtagset & 1 << i); i++) ;
+                       selmon->pertag->curtag = i + 1;
+               }
+
 		selmon->tagset[selmon->seltags] = newtagset;
+		/* apply settings for this view */
+               selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+               selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+               selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+               selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+               selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+               if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+                       togglebar(NULL);
+
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -1684,6 +1853,7 @@ void
 unfocus(Client *c, Bool setfocus) {
 	if(!c)
 		return;
+	prevclient = c;
 	grabbuttons(c, False);
 	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm].border->rgb);
 	if(setfocus) {
@@ -1969,11 +2139,34 @@ updatewmhints(Client *c) {
 
 void
 view(const Arg *arg) {
+	int i;
+       unsigned int tmptag;
+
 	if((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
 	selmon->seltags ^= 1; /* toggle sel tagset */
-	if(arg->ui & TAGMASK)
-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+	if(arg->ui & TAGMASK) {
+               selmon->pertag->prevtag = selmon->pertag->curtag;	
+	selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+	 if(arg->ui == ~0)
+                       selmon->pertag->curtag = 0;
+               else {
+                       for (i=0; !(arg->ui & 1 << i); i++) ;
+                       selmon->pertag->curtag = i + 1;
+               }
+       } else {
+               tmptag = selmon->pertag->prevtag;
+               selmon->pertag->prevtag = selmon->pertag->curtag;
+               selmon->pertag->curtag = tmptag;
+       }
+       selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+       selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+       selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+       selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+       selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+       if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+               togglebar(NULL);
+
 	focus(NULL);
 	arrange(selmon);
 }
@@ -2039,10 +2232,34 @@ xerrorstart(Display *dpy, XErrorEvent *ee) {
 	return -1;
 }
 
+                                                                                                        
+void
+view_adjacent(const Arg *arg)
+{
+        int i, curtags;
+        int seltag = 0;
+        Arg a;
+
+        curtags = selmon->tagset[selmon->seltags];
+        for(i = 0; i < LENGTH(tags); i++)
+                if(curtags & (1 << i)){
+                        seltag = i;
+                        break;
+                }   
+
+        seltag = (seltag + arg->i) % (int)LENGTH(tags);
+        if(seltag < 0)
+                seltag += LENGTH(tags);
+
+        a.i = (1 << seltag);
+        view(&a);
+}
+
+
 void
 zoom(const Arg *arg) {
 	Client *c = selmon->sel;
-
+        prevclient = selmon->clients;
 	if(!selmon->lt[selmon->sellt]->arrange
 	|| (selmon->sel && selmon->sel->isfloating))
 		return;
@@ -2052,6 +2269,142 @@ zoom(const Arg *arg) {
 	pop(c);
 }
 
+Client *
+prevtiled(Client *c) {
+        Client *p, *r;
+
+        for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
+                if(!p->isfloating && ISVISIBLE(p))
+                        r = p;
+        return r;
+}
+
+void
+pushup(const Arg *arg) {
+        Client *sel = selmon->sel;
+        Client *c;
+
+        if(!sel || sel->isfloating)
+                return;
+        if((c = prevtiled(sel))) {
+                /* attach before c */
+                detach(sel);
+                sel->next = c;
+                if(selmon->clients == c)
+                        selmon->clients = sel;
+                else {
+                        for(c = selmon->clients; c->next != sel->next; c = c->next);
+                        c->next = sel;
+                }
+        } else {
+                /* move to the end */
+                for(c = sel; c->next; c = c->next);
+                detach(sel);
+                sel->next = NULL;
+                c->next = sel;
+        }
+        focus(sel);
+        arrange(selmon);
+}
+
+void
+pushdown(const Arg *arg) {
+        Client *sel = selmon->sel;
+        Client *c;
+
+        if(!sel || sel->isfloating)
+                return;
+        if((c = nexttiled(sel->next))) {
+                /* attach after c */
+                detach(sel);
+                sel->next = c->next;
+                c->next = sel;
+        } else {
+                /* move to the front */
+                detach(sel);
+                attach(sel);
+        }
+        focus(sel);
+        arrange(selmon);
+}
+
+void
+centerwindow(const Arg *arg) {
+        if(!selmon->sel || !selmon->sel->isfloating || selmon->sel->isfullscreen)
+                return;
+        selmon->sel->x = selmon->sel->oldx = selmon->wx + (selmon->ww / 2 - selmon->sel->w / 2);
+        selmon->sel->y = selmon->sel->oldy = selmon->wy + (selmon->wh / 2 - selmon->sel->h / 2);
+        XMoveResizeWindow(dpy, selmon->sel->win, selmon->sel->x, selmon->sel->y, selmon->sel->w, selmon->sel->h);
+        arrange(selmon);
+}
+
+void
+fibonacci(Monitor *mon, int s) {
+       unsigned int i, n, nx, ny, nw, nh;
+       Client *c;
+
+       for(n = 0, 
+       c = nexttiled(mon->clients); 
+       c; c = nexttiled(c->next), n++);
+       if(n == 0)
+               return;
+       
+       nx = mon->wx;
+       ny = 0;
+       nw = mon->ww;
+       nh = mon->wh;
+       
+       for(i = 0, c = nexttiled(mon->clients); c; c = nexttiled(c->next)) {
+               if((i % 2 && nh / 2 > 2 * c->bw)
+                  || (!(i % 2) && nw / 2 > 2 * c->bw)) {
+                       if(i < n - 1) {
+                               if(i % 2)
+                                       nh /= 2;
+                               else
+                                       nw /= 2;
+                               if((i % 4) == 2 && !s)
+                                       nx += nw;
+                               else if((i % 4) == 3 && !s)
+                                       ny += nh;
+                       }
+                       if((i % 4) == 0) {
+                               if(s)
+                                       ny += nh;
+                               else
+                                       ny -= nh;
+                       }
+                       else if((i % 4) == 1)
+                               nx += nw;
+                       else if((i % 4) == 2)
+                               ny += nh;
+                       else if((i % 4) == 3) {
+                               if(s)
+                                       nx += nw;
+                               else
+                                       nx -= nw;
+                       }
+                       if(i == 0)
+                       {
+                               if(n != 1)
+                                       nw = mon->ww * mon->mfact;
+                               ny = mon->wy;
+                       }
+                       else if(i == 1)
+                               nw = mon->ww - nw;
+                       i++;
+               }
+               resize(c, nx, ny, nw - 2 * c->bw, nh - 2 * c->bw, False);
+       }
+}
+
+void
+spiral(Monitor *mon) {
+       fibonacci(mon, 1);
+}
+
+
+
+
 int
 main(int argc, char *argv[]) {
 	if(argc == 2 && !strcmp("-v", argv[1]))
